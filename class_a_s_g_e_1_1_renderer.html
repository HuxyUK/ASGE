<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASGE: ASGE::Renderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ASGE
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Simple Game Framework in GL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_a_s_g_e_1_1_renderer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_a_s_g_e_1_1_renderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ASGE::Renderer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ASGE::Renderer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_a_s_g_e_1_1_renderer__coll__graph.svg" width="195" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad78460aeb9906bb9526c3704dec0e8ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ad78460aeb9906bb9526c3704dec0e8ad">Renderer</a> ()=default</td></tr>
<tr class="separator:ad78460aeb9906bb9526c3704dec0e8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186e523f112d85fc78ce848caa702280"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a186e523f112d85fc78ce848caa702280">~Renderer</a> ()=default</td></tr>
<tr class="separator:a186e523f112d85fc78ce848caa702280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6606542f35c96dbe79e1a246bfb8fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#acf6606542f35c96dbe79e1a246bfb8fc">setClearColour</a> (<a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> rgb)=0</td></tr>
<tr class="separator:acf6606542f35c96dbe79e1a246bfb8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17ccd4294caaaf588fc89796367ca9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ae17ccd4294caaaf588fc89796367ca9a">loadFont</a> (const char *font, int size)</td></tr>
<tr class="separator:ae17ccd4294caaaf588fc89796367ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e88ddeadbf42413cd3e789d72a0f9e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a46e88ddeadbf42413cd3e789d72a0f9e">loadFont</a> (const char *font, int size, double range)=0</td></tr>
<tr class="separator:a46e88ddeadbf42413cd3e789d72a0f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d21bdfda1667dfe9ade6c6f9b25827"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a69d21bdfda1667dfe9ade6c6f9b25827">loadFontFromMem</a> (const char *name, const unsigned char *data, unsigned int len, int size, double range)=0</td></tr>
<tr class="separator:a69d21bdfda1667dfe9ade6c6f9b25827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89820c27ccab45a95a86c5a9c9642b09"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a89820c27ccab45a95a86c5a9c9642b09">loadFontAtlas</a> (<a class="el" href="struct_a_s_g_e_1_1_font_1_1_atlas_metrics.html">Font::AtlasMetrics</a> &amp;&amp;metrics, const std::string &amp;img_path, const std::string &amp;csv_path)=0</td></tr>
<tr class="separator:a89820c27ccab45a95a86c5a9c9642b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d44a34e0637fbabf15afd0ac53431c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ab3d44a34e0637fbabf15afd0ac53431c">init</a> (const <a class="el" href="struct_a_s_g_e_1_1_game_settings.html">ASGE::GameSettings</a> &amp;settings)=0</td></tr>
<tr class="separator:ab3d44a34e0637fbabf15afd0ac53431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e21f2479ec3c75e8b02d9aef2de0f32"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a2e21f2479ec3c75e8b02d9aef2de0f32">exit</a> ()=0</td></tr>
<tr class="separator:a2e21f2479ec3c75e8b02d9aef2de0f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a568c6276801e8b56bfdb04073b45e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a6a568c6276801e8b56bfdb04073b45e7">preRender</a> ()=0</td></tr>
<tr class="separator:a6a568c6276801e8b56bfdb04073b45e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15917804562361b81c9500844b713fc4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a15917804562361b81c9500844b713fc4">postRender</a> ()=0</td></tr>
<tr class="separator:a15917804562361b81c9500844b713fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6f953621eb739cd58f812ced3eebd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a39b6f953621eb739cd58f812ced3eebd">setDefaultTextColour</a> (const <a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;colour)=0</td></tr>
<tr class="separator:a39b6f953621eb739cd58f812ced3eebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fe72b6342e87b8d1bfc9a4e2c9e377"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#af0fe72b6342e87b8d1bfc9a4e2c9e377">findShader</a> (int shader_handle)=0</td></tr>
<tr class="separator:af0fe72b6342e87b8d1bfc9a4e2c9e377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4843715355469624c9e49d81ede46d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a6c4843715355469624c9e49d81ede46d">getDefaultFont</a> () const =0</td></tr>
<tr class="separator:a6c4843715355469624c9e49d81ede46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80006ed6ac343557e4ab654be2abd3f5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a80006ed6ac343557e4ab654be2abd3f5">getFont</a> (int idx) const =0</td></tr>
<tr class="separator:a80006ed6ac343557e4ab654be2abd3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e899c0c89d501243334920bde72d584"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a3e899c0c89d501243334920bde72d584">setFont</a> (int id)=0</td></tr>
<tr class="separator:a3e899c0c89d501243334920bde72d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c906e66c7c725d44d39a2612d9d2309"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a3c906e66c7c725d44d39a2612d9d2309">setSpriteMode</a> (<a class="el" href="namespace_a_s_g_e.html#a378b1aba7f572e3b328532ad06d0082b">SpriteSortMode</a> mode)=0</td></tr>
<tr class="separator:a3c906e66c7c725d44d39a2612d9d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7c1dd8718077292f56bb270916bee6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#aff7c1dd8718077292f56bb270916bee6">setWindowedMode</a> (<a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a> mode)=0</td></tr>
<tr class="separator:aff7c1dd8718077292f56bb270916bee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f4bff8a3f3eb76b053c47a67eb7e56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ae2f4bff8a3f3eb76b053c47a67eb7e56">setWindowTitle</a> (const char *str)=0</td></tr>
<tr class="separator:ae2f4bff8a3f3eb76b053c47a67eb7e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2ce0b669cab1762667440695d0ee2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#acc2ce0b669cab1762667440695d0ee2b">swapBuffers</a> ()=0</td></tr>
<tr class="separator:acc2ce0b669cab1762667440695d0ee2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f91a1cc580568ba2c401abb954cb4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="class_a_s_g_e_1_1_input.html">Input</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a883f91a1cc580568ba2c401abb954cb4">inputPtr</a> ()=0</td></tr>
<tr class="separator:a883f91a1cc580568ba2c401abb954cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38f3823044a6939b89592abd2b30b21"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="class_a_s_g_e_1_1_sprite.html">Sprite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ab38f3823044a6939b89592abd2b30b21">createUniqueSprite</a> ()=0</td></tr>
<tr class="separator:ab38f3823044a6939b89592abd2b30b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0b3953b5f8a4dd03e9d00cc85a72fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#aae0b3953b5f8a4dd03e9d00cc85a72fe">createRawSprite</a> ()=0</td></tr>
<tr class="separator:aae0b3953b5f8a4dd03e9d00cc85a72fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6ee0de87057138bc4c182ba6e9985"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ac0d6ee0de87057138bc4c182ba6e9985">render</a> (const <a class="el" href="class_a_s_g_e_1_1_sprite.html">ASGE::Sprite</a> &amp;sprite)=0</td></tr>
<tr class="separator:ac0d6ee0de87057138bc4c182ba6e9985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ecd6af347431315f3ddb2bc8c7cb19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#af5ecd6af347431315f3ddb2bc8c7cb19">render</a> (const <a class="el" href="struct_a_s_g_e_1_1_tile.html">ASGE::Tile</a> &amp;tile, const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a> &amp;xy)=0</td></tr>
<tr class="separator:af5ecd6af347431315f3ddb2bc8c7cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0ddd804a765f91bd47224d4d8f252"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ac9d0ddd804a765f91bd47224d4d8f252">render</a> (const <a class="el" href="struct_a_s_g_e_1_1_text.html">ASGE::Text</a> &amp;text)=0</td></tr>
<tr class="separator:ac9d0ddd804a765f91bd47224d4d8f252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0f3b2b24f298596032727370b9bde2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a4d0f3b2b24f298596032727370b9bde2">render</a> (<a class="el" href="struct_a_s_g_e_1_1_text.html">ASGE::Text</a> &amp;&amp;text)=0</td></tr>
<tr class="separator:a4d0f3b2b24f298596032727370b9bde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e9fabfca4eeee21bb4f14dfae70e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a33e9fabfca4eeee21bb4f14dfae70e95">render</a> (<a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> &amp;texture, const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a> &amp;pos_xy, int16_t z_order)</td></tr>
<tr class="separator:a33e9fabfca4eeee21bb4f14dfae70e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86a4fbb65c9678ea644e208e87ac2ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ac86a4fbb65c9678ea644e208e87ac2ca">render</a> (<a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> &amp;texture, std::array&lt; float, 4 &gt; rect, const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">Point2D</a> &amp;pos_xy, int width, int height, int16_t z_order)=0</td></tr>
<tr class="separator:ac86a4fbb65c9678ea644e208e87ac2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8ef2da864649cd275c99d6c4f489fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a3b8ef2da864649cd275c99d6c4f489fe">createNonCachedTexture</a> (int width, int height, <a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a> format, void *data)=0</td></tr>
<tr class="separator:a3b8ef2da864649cd275c99d6c4f489fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491ba53e28c7aff41e2445048b2c1a5e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a491ba53e28c7aff41e2445048b2c1a5e">createNonCachedMSAATexture</a> (int width, int height, <a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a> format)=0</td></tr>
<tr class="separator:a491ba53e28c7aff41e2445048b2c1a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6f9637e93f1859d1afbd416ffc517"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a6cf6f9637e93f1859d1afbd416ffc517">createNonCachedTexture</a> (const std::string &amp;path)=0</td></tr>
<tr class="separator:a6cf6f9637e93f1859d1afbd416ffc517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7f3949af5f43dfb47577aaa7d80652"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a7f7f3949af5f43dfb47577aaa7d80652">createCachedTexture</a> (std::string id, int width, int height, <a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a> format, void *data)=0</td></tr>
<tr class="separator:a7f7f3949af5f43dfb47577aaa7d80652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933abd39dcbe4dad57f69efc5fc9b285"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a933abd39dcbe4dad57f69efc5fc9b285">createCachedTextureArray</a> (std::string id, int width, int height, <a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a> format, void *data, int count)=0</td></tr>
<tr class="separator:a933abd39dcbe4dad57f69efc5fc9b285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c625e0be926f6aaf0f5deb872920bca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a7c625e0be926f6aaf0f5deb872920bca">createCachedTexture</a> (const std::string &amp;path)=0</td></tr>
<tr class="separator:a7c625e0be926f6aaf0f5deb872920bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c139e19c20ccc24363c64342c616a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a7c139e19c20ccc24363c64342c616a2d">initPixelShaderFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a7c139e19c20ccc24363c64342c616a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19479bb7912162798257a42bc5da96cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a19479bb7912162798257a42bc5da96cf">initPixelShader</a> (std::string shader)=0</td></tr>
<tr class="separator:a19479bb7912162798257a42bc5da96cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4630c15c0fd3ca6d72a44cc4f0a9907"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ad4630c15c0fd3ca6d72a44cc4f0a9907">setActiveShader</a> (<a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">ASGE::SHADER_LIB::Shader</a> *shader)=0</td></tr>
<tr class="separator:ad4630c15c0fd3ca6d72a44cc4f0a9907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b14b34f519a0bd0c00358e0f860c9cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a1b14b34f519a0bd0c00358e0f860c9cb">getShader</a> ()=0</td></tr>
<tr class="separator:a1b14b34f519a0bd0c00358e0f860c9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac280373dc1516bdcdf5a701126180c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ac280373dc1516bdcdf5a701126180c23">getWindowMode</a> () noexcept</td></tr>
<tr class="separator:ac280373dc1516bdcdf5a701126180c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a727c09d0887f527cb2f669139ed3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a83a727c09d0887f527cb2f669139ed3b">windowHeight</a> () const noexcept=0</td></tr>
<tr class="separator:a83a727c09d0887f527cb2f669139ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764de80b18463e7a12c23a156bade4ca"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a764de80b18463e7a12c23a156bade4ca">windowWidth</a> () const noexcept=0</td></tr>
<tr class="separator:a764de80b18463e7a12c23a156bade4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936502dcaef8c46a0d24c146221fa160"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a936502dcaef8c46a0d24c146221fa160">setProjectionMatrix</a> (float min_x, float max_x, float min_y, float max_y)=0</td></tr>
<tr class="separator:a936502dcaef8c46a0d24c146221fa160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8fe027bcb9cbf19635ffe24f6169e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a5b8fe027bcb9cbf19635ffe24f6169e0">setProjectionMatrix</a> (const <a class="el" href="struct_a_s_g_e_1_1_camera_1_1_camera_view.html">Camera::CameraView</a> &amp;view)=0</td></tr>
<tr class="separator:a5b8fe027bcb9cbf19635ffe24f6169e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7796ffb25fc44620c9f241c6918e032"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_a_s_g_e_1_1_viewport.html">ASGE::Viewport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ab7796ffb25fc44620c9f241c6918e032">getViewport</a> () const =0</td></tr>
<tr class="separator:ab7796ffb25fc44620c9f241c6918e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae664e9870d954c9352227a1f395860a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ae664e9870d954c9352227a1f395860a8">setViewport</a> (const <a class="el" href="struct_a_s_g_e_1_1_viewport.html">ASGE::Viewport</a> &amp;viewport)=0</td></tr>
<tr class="separator:ae664e9870d954c9352227a1f395860a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0f9d3f59ffde1be2263365525cd41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a5bb0f9d3f59ffde1be2263365525cd41">setRenderTarget</a> (<a class="el" href="class_a_s_g_e_1_1_render_target.html">RenderTarget</a> *)=0</td></tr>
<tr class="separator:a5bb0f9d3f59ffde1be2263365525cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae985697292395416b3fd441f4966fc"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; int32_t, int32_t, int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a0ae985697292395416b3fd441f4966fc">screenRes</a> ()=0</td></tr>
<tr class="separator:a0ae985697292395416b3fd441f4966fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c362f0145efb8f1ff5a90b5d8193c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#ad8c362f0145efb8f1ff5a90b5d8193c6">setBaseResolution</a> (int width, int height, <a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">Resolution::Policy</a> policy)=0</td></tr>
<tr class="separator:ad8c362f0145efb8f1ff5a90b5d8193c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73561ae9b48e32678403502157770a9e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_a_s_g_e_1_1_resolution.html">ASGE::Resolution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a73561ae9b48e32678403502157770a9e">resolution</a> () const =0</td></tr>
<tr class="separator:a73561ae9b48e32678403502157770a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dcca5749a28579cc2409b0e91ce18c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#af1dcca5749a28579cc2409b0e91ce18c">setResolutionPolicy</a> (<a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">ASGE::Resolution::Policy</a>)=0</td></tr>
<tr class="separator:af1dcca5749a28579cc2409b0e91ce18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbae0fcb8c066d2f8bc1b97e3920e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#aebbae0fcb8c066d2f8bc1b97e3920e58">renderTarget</a> ()</td></tr>
<tr class="separator:aebbae0fcb8c066d2f8bc1b97e3920e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc67dab1f554c11520f49e2fcb946484"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#afc67dab1f554c11520f49e2fcb946484">renderTarget</a> () const</td></tr>
<tr class="separator:afc67dab1f554c11520f49e2fcb946484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa2e02b1bcecd36fd3892c1ff9bbe27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a7aa2e02b1bcecd36fd3892c1ff9bbe27">msaa</a> () const</td></tr>
<tr class="separator:a7aa2e02b1bcecd36fd3892c1ff9bbe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8423b1f8900a92c211985f1f6f82873c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a5bcdb98d09f05c5e0df6f8b596773ed5">ASGE::Texture2D::MagFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a8423b1f8900a92c211985f1f6f82873c">magFilter</a> () const</td></tr>
<tr class="separator:a8423b1f8900a92c211985f1f6f82873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7ff3ac137baf47f4daf8d0dba4cd88ba"><td class="memItemLeft" align="right" valign="top"><a id="a7ff3ac137baf47f4daf8d0dba4cd88ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>msaa</b> (int msaa_level)</td></tr>
<tr class="separator:a7ff3ac137baf47f4daf8d0dba4cd88ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8924bc45c12d489a4bc974ad2407a8"><td class="memItemLeft" align="right" valign="top"><a id="abf8924bc45c12d489a4bc974ad2407a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>magFilter</b> (<a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a5bcdb98d09f05c5e0df6f8b596773ed5">ASGE::Texture2D::MagFilter</a> mag)</td></tr>
<tr class="separator:abf8924bc45c12d489a4bc974ad2407a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba17e3c4d46b7d45d64b73bec5559a1"><td class="memItemLeft" align="right" valign="top"><a id="a2ba17e3c4d46b7d45d64b73bec5559a1"></a>
<a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>windowMode</b> ()</td></tr>
<tr class="separator:a2ba17e3c4d46b7d45d64b73bec5559a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83764bc6d0f0bd3ccdf47fbb3c8868fd"><td class="memItemLeft" align="right" valign="top"><a id="a83764bc6d0f0bd3ccdf47fbb3c8868fd"></a>
const <a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>windowMode</b> () const</td></tr>
<tr class="separator:a83764bc6d0f0bd3ccdf47fbb3c8868fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e8fd3328b7535130fa66487e399e7e"><td class="memItemLeft" align="right" valign="top"><a id="a32e8fd3328b7535130fa66487e399e7e"></a>
<a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>clearColour</b> ()</td></tr>
<tr class="separator:a32e8fd3328b7535130fa66487e399e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87f0461a31c0376d29a5807f404049"><td class="memItemLeft" align="right" valign="top"><a id="a8b87f0461a31c0376d29a5807f404049"></a>
const <a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>clearColour</b> () const</td></tr>
<tr class="separator:a8b87f0461a31c0376d29a5807f404049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff248944f23ce0f9b6f3511efd691a5"><td class="memItemLeft" align="right" valign="top"><a id="a2ff248944f23ce0f9b6f3511efd691a5"></a>
<a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>defTextColour</b> ()</td></tr>
<tr class="separator:a2ff248944f23ce0f9b6f3511efd691a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ade72d94d370ef71a4a89a9205dc545"><td class="memItemLeft" align="right" valign="top"><a id="a9ade72d94d370ef71a4a89a9205dc545"></a>
const <a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>defTextColour</b> () const</td></tr>
<tr class="separator:a9ade72d94d370ef71a4a89a9205dc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a90d74e4ea8451e7a6251fcab699c8c1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_renderer.html#a90d74e4ea8451e7a6251fcab699c8c1d">active_buffer</a> { nullptr }</td></tr>
<tr class="separator:a90d74e4ea8451e7a6251fcab699c8c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The renderer used in the game. </p>
<p>The renderer is the heart and sole of the engine. It's responsible for managing rendering, shaders input initialisation, the window etc. This class defines the interface that all platform specific renders must utilise. This allows renderers to be replaced easily if their interface matches. The platform specific renders may use batching or texture caching but this is not enforced. </p>

<p class="definition">Definition at line <a class="el" href="_renderer_8hpp_source.html#l00051">51</a> of file <a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad78460aeb9906bb9526c3704dec0e8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78460aeb9906bb9526c3704dec0e8ad">&#9670;&nbsp;</a></span>Renderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ASGE::Renderer::Renderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>The renderer is an abstract class that does not know about the rendering implementation details. Its primary use is as an interface that all rendering subsystems need to adhere to. </p>

</div>
</div>
<a id="a186e523f112d85fc78ce848caa702280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186e523f112d85fc78ce848caa702280">&#9670;&nbsp;</a></span>~Renderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ASGE::Renderer::~Renderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c625e0be926f6aaf0f5deb872920bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c625e0be926f6aaf0f5deb872920bca">&#9670;&nbsp;</a></span>createCachedTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createCachedTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a cached texture from a file. </p>
<p>A cached texture is one which is managed by the renderer. Upon its successful creation it will be stored using its file path. Subsequent retrievals of a texture with the same ID will result in the cached version being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The texture to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly cached Texture. </dd></dl>

</div>
</div>
<a id="a7f7f3949af5f43dfb47577aaa7d80652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7f3949af5f43dfb47577aaa7d80652">&#9670;&nbsp;</a></span>createCachedTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createCachedTexture </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a cached texture. </p>
<p>A cached texture is one which is managed by the renderer. Upon its successful creation it will be stored using its ID. Subsequent retrievals of a texture with the same ID will result in the cached version being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The unique ID for the texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the newly created texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the newly created texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The pixel format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Existing pixel data to use. Can be nullptr (empty).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the cached <a class="el" href="class_a_s_g_e_1_1_texture2_d.html" title="a simple 2D non-renderable texture.">ASGE::Texture2D</a> matching the requested ID </dd></dl>

</div>
</div>
<a id="a933abd39dcbe4dad57f69efc5fc9b285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933abd39dcbe4dad57f69efc5fc9b285">&#9670;&nbsp;</a></span>createCachedTextureArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createCachedTextureArray </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a cached version of a 2D Texture Array. </p>
<p>2D Texture Arrays can be used to store images on different layers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The unique id to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the textures in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the textures in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The format of the pixels being stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Initial data to upload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of layers to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the cached <a class="el" href="class_a_s_g_e_1_1_texture2_d.html" title="a simple 2D non-renderable texture.">ASGE::Texture2D</a> </dd></dl>

</div>
</div>
<a id="a491ba53e28c7aff41e2445048b2c1a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491ba53e28c7aff41e2445048b2c1a5e">&#9670;&nbsp;</a></span>createNonCachedMSAATexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createNonCachedMSAATexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a non-cached multi-sampling texture. </p>
<p>A non-cached texture is created and assigned to the GPU. The size of the allocation depends on both the dimensions and the pixel format. As the texture is not cached by <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a>, responsibility for its destruction is left to the callee.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the newly created MSAA texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the newly created MSAA texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The pixel format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created Texture. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Don't forget to deallocate the memory the function call allocates. </dd></dl>

</div>
</div>
<a id="a6cf6f9637e93f1859d1afbd416ffc517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf6f9637e93f1859d1afbd416ffc517">&#9670;&nbsp;</a></span>createNonCachedTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createNonCachedTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to create a non-cached texture from a file. </p>
<p>A non-cached texture is created and assigned to the GPU. The size of the allocation depends on both the dimensions and the pixel format. As the texture is not cached by <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a>, responsibility for its destruction is left to the callee.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The texture to load.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created Texture. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Don't forget to deallocate the memory the function call allocates. </dd></dl>

</div>
</div>
<a id="a3b8ef2da864649cd275c99d6c4f489fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8ef2da864649cd275c99d6c4f489fe">&#9670;&nbsp;</a></span>createNonCachedTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* ASGE::Renderer::createNonCachedTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#af7841112f5f42d8bd299acd8e93e6fd7">ASGE::Texture2D::Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a non-cached texture. </p>
<p>A non-cached texture is created and assigned to the GPU. The size of the allocation depends on both the dimensions and the pixel format. As the texture is not cached by <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a>, responsibility for its destruction is left to the callee.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the newly created texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the newly created texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>The pixel format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Existing pixel data to use. Can be nullptr (empty).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created Texture. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Don't forget to deallocate the memory the function call allocates. </dd></dl>

</div>
</div>
<a id="aae0b3953b5f8a4dd03e9d00cc85a72fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0b3953b5f8a4dd03e9d00cc85a72fe">&#9670;&nbsp;</a></span>createRawSprite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_sprite.html">Sprite</a>* ASGE::Renderer::createRawSprite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> using the heap. </p>
<p>The sprite will be leaked when it falls out of scope, so needs to be manually freed.</p>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated sprite. </dd></dl>

</div>
</div>
<a id="ab38f3823044a6939b89592abd2b30b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38f3823044a6939b89592abd2b30b21">&#9670;&nbsp;</a></span>createUniqueSprite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="class_a_s_g_e_1_1_sprite.html">Sprite</a>&gt; ASGE::Renderer::createUniqueSprite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> using ownership semantics. </p>
<p>The sprite will be auto-deallocated when it falls out of scope, so be careful where to store it.</p>
<dl class="section return"><dt>Returns</dt><dd>A uniquely owned sprite. </dd></dl>

</div>
</div>
<a id="a2e21f2479ec3c75e8b02d9aef2de0f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e21f2479ec3c75e8b02d9aef2de0f32">&#9670;&nbsp;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ASGE::Renderer::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exits the renderer and performs clean-up. </p><dl class="section return"><dt>Returns</dt><dd>True if achieved gracefully. </dd></dl>

</div>
</div>
<a id="af0fe72b6342e87b8d1bfc9a4e2c9e377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fe72b6342e87b8d1bfc9a4e2c9e377">&#9670;&nbsp;</a></span>findShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Renderer::findShader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shader_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates a shader using its ID. </p>
<p>Shaders are stored/cached so to prevent dangling pointers handle's can be used to retrieve the shader. It is recommended not to store the returned shader as it's memory location could change over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shader_handle</td><td>The shader to find. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c4843715355469624c9e49d81ede46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4843715355469624c9e49d81ede46d">&#9670;&nbsp;</a></span>getDefaultFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>&amp; ASGE::Renderer::getDefaultFont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently active font. </p>
<p>When rendering text, if a colour is not specified the default one will be used instead. This can be set using this function.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_s_g_e_1_1_font.html" title="A font used to render text.">Font</a> The font currently being used by the renderer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_font.html" title="A font used to render text.">Font</a> </dd></dl>

</div>
</div>
<a id="a80006ed6ac343557e4ab654be2abd3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80006ed6ac343557e4ab654be2abd3f5">&#9670;&nbsp;</a></span>getFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>&amp; ASGE::Renderer::getFont </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a font. </p>
<p>When loading fonts they will be assigned an index, you can retrieve the font using its index to access additional font related functionality</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The loaded font index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_s_g_e_1_1_font.html" title="A font used to render text.">Font</a> The font stored in idx otherwise current loaded </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_font.html" title="A font used to render text.">Font</a> </dd></dl>

</div>
</div>
<a id="a1b14b34f519a0bd0c00358e0f860c9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b14b34f519a0bd0c00358e0f860c9cb">&#9670;&nbsp;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Renderer::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the current shader being used for rendering. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the active shader (if any). </dd></dl>

</div>
</div>
<a id="ab7796ffb25fc44620c9f241c6918e032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7796ffb25fc44620c9f241c6918e032">&#9670;&nbsp;</a></span>getViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_a_s_g_e_1_1_viewport.html">ASGE::Viewport</a> ASGE::Renderer::getViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the viewport used to map the renderer to the window. </p>
<dl class="section return"><dt>Returns</dt><dd>Retrieves the active viewport. </dd></dl>

</div>
</div>
<a id="ac280373dc1516bdcdf5a701126180c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac280373dc1516bdcdf5a701126180c23">&#9670;&nbsp;</a></span>getWindowMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a> ASGE::Renderer::getWindowMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the window mode in use. </p><dl class="section return"><dt>Returns</dt><dd>The window mode. </dd></dl>

</div>
</div>
<a id="ab3d44a34e0637fbabf15afd0ac53431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d44a34e0637fbabf15afd0ac53431c">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ASGE::Renderer::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_game_settings.html">ASGE::GameSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the renderer. </p>
<p>Performs all the initialisation of the renderer, its framework and the window creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the window in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the window in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Should the window launch in fullscreen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>WindowMode </dd></dl>

</div>
</div>
<a id="a19479bb7912162798257a42bc5da96cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19479bb7912162798257a42bc5da96cf">&#9670;&nbsp;</a></span>initPixelShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Renderer::initPixelShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises a pixel shader.</p>
<p><b>GLSL Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"><span class="preprocessor">#define FRAG_COLOUR     0</span></div>
<div class="line">in VertexData</div>
<div class="line">{</div>
<div class="line">  vec2    uvs;</div>
<div class="line">  vec4    rgba;</div>
<div class="line">} fs_in;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D image;</div>
<div class="line">layout  (location = FRAG_COLOUR, index = 0) out vec4 FragColor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">  FragColor = fs_in.rgba * texture(image, fs_in.uvs);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shader</td><td>The plain text representing a pixel shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resultant shader object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The shader is managed by the renderer. It does not need to be manually deallocated. </dd></dl>

</div>
</div>
<a id="a7c139e19c20ccc24363c64342c616a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c139e19c20ccc24363c64342c616a2d">&#9670;&nbsp;</a></span>initPixelShaderFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Renderer::initPixelShaderFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialises a pixel shader stored from a local file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The file to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resultant shader object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The shader is managed by the renderer. It does not need to be manually deallocated. </dd></dl>

</div>
</div>
<a id="a883f91a1cc580568ba2c401abb954cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f91a1cc580568ba2c401abb954cb4">&#9670;&nbsp;</a></span>inputPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="class_a_s_g_e_1_1_input.html">Input</a>&gt; ASGE::Renderer::inputPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an input system, linked to the renderer. </p><dl class="section return"><dt>Returns</dt><dd>A uniquely owned input system. </dd></dl>

</div>
</div>
<a id="ae17ccd4294caaaf588fc89796367ca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17ccd4294caaaf588fc89796367ca9a">&#9670;&nbsp;</a></span>loadFont() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>* ASGE::Renderer::loadFont </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a font that can be used to render text. Creates an SDF set of characters that can be used to render text. This version of the function will attempt to load a local file and convert the font using a distance range of 2.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">font</td><td>The filepath to the font file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the glyphs to use in atlas generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the loaded font. </dd></dl>

</div>
</div>
<a id="a46e88ddeadbf42413cd3e789d72a0f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e88ddeadbf42413cd3e789d72a0f9e">&#9670;&nbsp;</a></span>loadFont() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>* ASGE::Renderer::loadFont </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a font that can be used to render text. Creates an SDF set of characters that can be used to render text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">font</td><td>The filepath to the font file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the glyphs to use in atlas generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>The distance range to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the loaded font. </dd></dl>

</div>
</div>
<a id="a89820c27ccab45a95a86c5a9c9642b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89820c27ccab45a95a86c5a9c9642b09">&#9670;&nbsp;</a></span>loadFontAtlas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>* ASGE::Renderer::loadFontAtlas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_font_1_1_atlas_metrics.html">Font::AtlasMetrics</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>img_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a font atlas that can be used to render text. Attempts to create a new atlas for rendering text using a pre-existing image file and accompanying CSV file. The advantage to this is the ability to use more computationally expensive algorithms and a significant reduction in load times. This function was designed with <a href="https://github.com/Chlumsky/msdf-atlas-gen/tree/master/msdf-atlas-gen">msdf-atlas-gen</a> in mind. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics</td><td>The font metrics used to render text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img_path</td><td>The location of the image file to load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">csv_path</td><td>The CSV data that defines each glyph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d21bdfda1667dfe9ade6c6f9b25827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d21bdfda1667dfe9ade6c6f9b25827">&#9670;&nbsp;</a></span>loadFontFromMem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_s_g_e_1_1_font.html">Font</a>* ASGE::Renderer::loadFontFromMem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a font that can be used to render text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the font. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A binary font loaded in memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the font to use in atlas generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the loaded font. </dd></dl>

</div>
</div>
<a id="a8423b1f8900a92c211985f1f6f82873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8423b1f8900a92c211985f1f6f82873c">&#9670;&nbsp;</a></span>magFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a5bcdb98d09f05c5e0df6f8b596773ed5">ASGE::Texture2D::MagFilter</a> ASGE::Renderer::magFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the default MagFilter. All textures when sampled beyond their resolution need to be magnified. This is the default value the game will use when no filter has been individually set on a texture.</p>
<dl class="section return"><dt>Returns</dt><dd>The default magnification filter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#a4f5fbd285238b66b6e41e588f80f7e0c">ASGE::Texture2D::MagFilter</a> </dd></dl>

</div>
</div>
<a id="a7aa2e02b1bcecd36fd3892c1ff9bbe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa2e02b1bcecd36fd3892c1ff9bbe27">&#9670;&nbsp;</a></span>msaa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASGE::Renderer::msaa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the MSAA level. When the game is setup the MSAA level is set on the window. This can't be adjusted during runtime, however, its value can be retrieved and used to create additional MSAA buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>The MSAA level to use. </dd></dl>

</div>
</div>
<a id="a15917804562361b81c9500844b713fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15917804562361b81c9500844b713fc4">&#9670;&nbsp;</a></span>postRender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::postRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the post render environment. </p>
<p>Can be used amongst other things to update OSD settings and to flush batched render calls. </p>

</div>
</div>
<a id="a6a568c6276801e8b56bfdb04073b45e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a568c6276801e8b56bfdb04073b45e7">&#9670;&nbsp;</a></span>preRender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::preRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pre render environment. </p>
<p>Can be used amongst other things to reset render settings and to clear the screen. </p>

</div>
</div>
<a id="a4d0f3b2b24f298596032727370b9bde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0f3b2b24f298596032727370b9bde2">&#9670;&nbsp;</a></span>render() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_text.html">ASGE::Text</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renders a temporary text object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>The temporary text object to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e9fabfca4eeee21bb4f14dfae70e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e9fabfca4eeee21bb4f14dfae70e95">&#9670;&nbsp;</a></span>render() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>z_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a texture. </p>
<p>Acts as as simple proxy function for rendering textures. This shorthand function actually calls the longhand version of the function using the texture's own properties to define sensible defaults i.e. sample the whole texture and render it at the same width and height it was originally defined as.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>The texture to render. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_xy</td><td>The xy position of the rendered texture in 2D Space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_order</td><td>The z-ordering to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac86a4fbb65c9678ea644e208e87ac2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a4fbb65c9678ea644e208e87ac2ca">&#9670;&nbsp;</a></span>render() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; float, 4 &gt;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">Point2D</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>z_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a texture to the screen or attached buffer. </p>
<p>Typically an <a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">ASGE::Sprite</a> is used for rendering. Textures are attached to these objects and the positional and source rectangle information is used to generate the matrices required for rendering. However, on occasion it might be preferable to store a texture directly without the extra positional data. For example a tile map can be made up from a list or array of textures. When rendering the absolute position can be forwarded on to the renderer along with the UV mapping and this function will take care of the rest (it basically maps to a temporary sprite object).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [width, height, std::ignore] = renderer-&gt;screenRes();</div>
<div class="line"><span class="keyword">struct </span>Tile</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a>* texture = <span class="keyword">nullptr</span>;</div>
<div class="line">    std::array&lt;float,4&gt; source_rectangle {0};</div>
<div class="line"> };</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// create a tile with a texture and source rectangle</span></div>
<div class="line"> Tile tile;</div>
<div class="line"> tile.texture = renderer-&gt;createCachedTexture(<span class="stringliteral">&quot;/data/img/tile_sheet.png&quot;</span>);</div>
<div class="line"> tile.source_rectangle = {0, 0, 64, 64};</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// some moments later</span></div>
<div class="line"> renderer-&gt;render(*tile.texture, tile.source_rectangle, <a class="code" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a>{0,0}, 64, 64);</div>
<div class="ttc" id="aclass_a_s_g_e_1_1_texture2_d_html"><div class="ttname"><a href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a></div><div class="ttdoc">a simple 2D non-renderable texture.</div><div class="ttdef"><b>Definition:</b> <a href="_texture_8hpp_source.html#l00056">Texture.hpp:57</a></div></div>
<div class="ttc" id="astruct_a_s_g_e_1_1_point2_d_html"><div class="ttname"><a href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a></div><div class="ttdoc">A point in 2D space.</div><div class="ttdef"><b>Definition:</b> <a href="_point2_d_8hpp_source.html#l00030">Point2D.hpp:31</a></div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>The texture to be sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The source rectangle to use when sampling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_xy</td><td>The position to render the texture in 2D space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>How wide to render it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>How tall to render it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_order</td><td>The z ordering to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0d6ee0de87057138bc4c182ba6e9985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6ee0de87057138bc4c182ba6e9985">&#9670;&nbsp;</a></span>render() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_g_e_1_1_sprite.html">ASGE::Sprite</a> &amp;&#160;</td>
          <td class="paramname"><em>sprite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a sprite to the screen. </p>
<p>All the rendering params are stored within the sprite class itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sprite</td><td>A reference to the sprite to render. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> </dd></dl>

</div>
</div>
<a id="ac9d0ddd804a765f91bd47224d4d8f252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d0ddd804a765f91bd47224d4d8f252">&#9670;&nbsp;</a></span>render() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_text.html">ASGE::Text</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renders a text object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>The text object to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5ecd6af347431315f3ddb2bc8c7cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ecd6af347431315f3ddb2bc8c7cb19">&#9670;&nbsp;</a></span>render() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_tile.html">ASGE::Tile</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a> &amp;&#160;</td>
          <td class="paramname"><em>xy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renders a tile object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile</td><td>The text object to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebbae0fcb8c066d2f8bc1b97e3920e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbae0fcb8c066d2f8bc1b97e3920e58">&#9670;&nbsp;</a></span>renderTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a>* ASGE::Renderer::renderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets any active render target. Retrieves the active buffer object. This will be nullptr if there is currently no render target active.</p>
<dl class="section return"><dt>Returns</dt><dd>The active render target. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_renderer_8hpp_source.html#l00665">665</a> of file <a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>.</p>

</div>
</div>
<a id="afc67dab1f554c11520f49e2fcb946484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc67dab1f554c11520f49e2fcb946484">&#9670;&nbsp;</a></span>renderTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a>* ASGE::Renderer::renderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets any active render target. Retrieves the active buffer object. This will be nullptr if there is currently no render target active.</p>
<dl class="section return"><dt>Returns</dt><dd>The active render target. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_renderer_8hpp_source.html#l00674">674</a> of file <a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>.</p>

</div>
</div>
<a id="a73561ae9b48e32678403502157770a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73561ae9b48e32678403502157770a9e">&#9670;&nbsp;</a></span>resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_a_s_g_e_1_1_resolution.html">ASGE::Resolution</a>&amp; ASGE::Renderer::resolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the resolution information. The resolution data structure stores information such as the current active viewport, the window width and height, the base resolution and the desktop resolution.</p>
<dl class="section return"><dt>Returns</dt><dd>The resolution information. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_resolution.html">ASGE::Resolution</a> </dd></dl>

</div>
</div>
<a id="a0ae985697292395416b3fd441f4966fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae985697292395416b3fd441f4966fc">&#9670;&nbsp;</a></span>screenRes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::tuple&lt;int32_t, int32_t, int16_t&gt; ASGE::Renderer::screenRes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves information about the screen the window is on. </p>
<p>Retrieves information on the screen the window resides on. In particular it provides information about the width, height and the refresh rate of the screen. Returned as a tuple to allow the use of structured bindings.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [width, height, std::ignore] = renderer-&gt;screenRes();</div>
<div class="line"><span class="keyword">auto</span> [width, height, refresh]     = renderer-&gt;screenRes();</div>
<div class="line"><a class="code" href="namespace_logging.html#aab7e023b2391189ef7851e3994d39dec">Logging::INFO</a>(std::to_string(width) + <span class="stringliteral">&quot;,&quot;</span> +</div>
<div class="line">              std::to_string(height)+ <span class="stringliteral">&quot;,&quot;</span> + std::to_string(refresh));</div>
<div class="ttc" id="anamespace_logging_html_aab7e023b2391189ef7851e3994d39dec"><div class="ttname"><a href="namespace_logging.html#aab7e023b2391189ef7851e3994d39dec">Logging::INFO</a></div><div class="ttdeci">void INFO(const std::string &amp;message)</div><div class="ttdef"><b>Definition:</b> <a href="_logger_8hpp_source.html#l00302">Logger.hpp:302</a></div></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>The screen mode info: width, height and refresh rate. </dd></dl>

</div>
</div>
<a id="ad4630c15c0fd3ca6d72a44cc4f0a9907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4630c15c0fd3ca6d72a44cc4f0a9907">&#9670;&nbsp;</a></span>setActiveShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setActiveShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">ASGE::SHADER_LIB::Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the shader to use when rendering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shader</td><td>The shader to activate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8c362f0145efb8f1ff5a90b5d8193c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c362f0145efb8f1ff5a90b5d8193c6">&#9670;&nbsp;</a></span>setBaseResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setBaseResolution </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">Resolution::Policy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the base (game) resolution. </p>
<p>When designing the game, the positioning, scaling and logic will be implemented with a specific "resolution" in mind. However, when rendering the window size may not match the base resolution correctly, resulting in scaling. Setting this will allow the window to resize correctly, depending on the policy used. Designing games to support multiple resolutions is quite tricky and this function aims to help with this complexity. Simply set your game resolution and let the policy do the work for you.</p>
<dl class="section note"><dt>Note</dt><dd>The base resolution is not in pixels, rather game units. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width.</td><td>The width the game was designed in. </td></tr>
    <tr><td class="paramname">height.</td><td>The height the game was designed in. </td></tr>
    <tr><td class="paramname">policy.</td><td>The scaling policy to apply when window size does not match.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// game is 1024,768 units; scale to window but retain its aspect ratio</span></div>
<div class="line">renderer-&gt;setBaseResolution(1024, 768, <a class="code" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9ba00276e35c83621d2dc419ee7f020e375">ASGE::Resolution::Policy::MAINTAIN</a>);</div>
<div class="ttc" id="aclass_a_s_g_e_1_1_resolution_html_aea5c1fda253f6032773002bf6f28cd9ba00276e35c83621d2dc419ee7f020e375"><div class="ttname"><a href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9ba00276e35c83621d2dc419ee7f020e375">ASGE::Resolution::Policy::MAINTAIN</a></div><div class="ttdeci">@ MAINTAIN</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">Resolution::Policy</a> </dd></dl>

</div>
</div>
<a id="acf6606542f35c96dbe79e1a246bfb8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6606542f35c96dbe79e1a246bfb8fc">&#9670;&nbsp;</a></span>setClearColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setClearColour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the clear colour. </p>
<p>This colour will be used to clear the window on every update. Allowing a clean slate before performing the next render.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgb[in]</td><td>A RGB defined colour to use for clearing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_colour.html" title="RGB Helper.">Colour</a> </dd></dl>

</div>
</div>
<a id="a39b6f953621eb739cd58f812ced3eebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b6f953621eb739cd58f812ced3eebd">&#9670;&nbsp;</a></span>setDefaultTextColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setDefaultTextColour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default text colour. </p>
<p>When rendering text, if a colour is not specified the default one will be used instead. This can be set using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">colour</td><td>The colour to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e899c0c89d501243334920bde72d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e899c0c89d501243334920bde72d584">&#9670;&nbsp;</a></span>setFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setFont </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the currently active font. </p>
<p>In order for this to work, a valid id must be provided. The ID is returned from the load font function, so it is advisable to keep a record of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The index of the font to use (must be loaded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>since 2.1 </dd></dl>

</div>
</div>
<a id="a5b8fe027bcb9cbf19635ffe24f6169e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8fe027bcb9cbf19635ffe24f6169e0">&#9670;&nbsp;</a></span>setProjectionMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_camera_1_1_camera_view.html">Camera::CameraView</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the projection matrix. </p>
<p>Controls how the scene is rendered to the window. The projection matrix can be thought of as the camera's view, detailing the focal point and the content to include either side of the mid-point. This projection matrix may be stretched to accommodate the viewport used to render to the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">view.</td><td>The camera view to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a936502dcaef8c46a0d24c146221fa160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936502dcaef8c46a0d24c146221fa160">&#9670;&nbsp;</a></span>setProjectionMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the projection matrix. </p>
<p>Controls how the scene is rendered to the window. The projection matrix can be thought of as the camera's view, detailing the focal point and the content to include either side of the mid-point. This projection matrix may be stretched to accommodate the viewport used to render to the window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_x</td><td>The camera's look at x position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_x</td><td>The camera's look at y position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_y</td><td>The camera's frustum width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_y</td><td>The camera's frustum height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb0f9d3f59ffde1be2263365525cd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0f9d3f59ffde1be2263365525cd41">&#9670;&nbsp;</a></span>setRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_render_target.html">RenderTarget</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the render target to use for rendering. </p>
<p>Instead of rendering directly to the screen, a render target with an attached texture can be directly rendered to. This allows for off-screen rendering as well as an easier to manage post-fx pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">render_target.</td><td>The destination target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1dcca5749a28579cc2409b0e91ce18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dcca5749a28579cc2409b0e91ce18c">&#9670;&nbsp;</a></span>setResolutionPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setResolutionPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">ASGE::Resolution::Policy</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the resolution policy. Defines how scaling should take place. There are a number of policies that control how mapping of the game's resolution to the window should take place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">policy.</td><td>The policy to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Changing the policy will reset the current viewport. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_resolution.html#aea5c1fda253f6032773002bf6f28cd9b">ASGE::Resolution::Policy</a> </dd></dl>

</div>
</div>
<a id="a3c906e66c7c725d44d39a2612d9d2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c906e66c7c725d44d39a2612d9d2309">&#9670;&nbsp;</a></span>setSpriteMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setSpriteMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_a_s_g_e.html#a378b1aba7f572e3b328532ad06d0082b">SpriteSortMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the sprite rendering mode. Useful for batching. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SpriteSortMode used for rendering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_a_s_g_e.html#a378b1aba7f572e3b328532ad06d0082b" title="modes to control the batching of sprites">SpriteSortMode</a> </dd></dl>

</div>
</div>
<a id="ae664e9870d954c9352227a1f395860a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae664e9870d954c9352227a1f395860a8">&#9670;&nbsp;</a></span>setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_s_g_e_1_1_viewport.html">ASGE::Viewport</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the viewport used to map the x,y ndc to the window or buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Sets the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff7c1dd8718077292f56bb270916bee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7c1dd8718077292f56bb270916bee6">&#9670;&nbsp;</a></span>setWindowedMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setWindowedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a0b97506ca8a111895b5603988d94e87e">GameSettings::WindowMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to enable the requested window mode. </p>
<p>Will only swap if the mode is different and will attempt to perform this operation gracefully as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The requested window mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f4bff8a3f3eb76b053c47a67eb7e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f4bff8a3f3eb76b053c47a67eb7e56">&#9670;&nbsp;</a></span>setWindowTitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::setWindowTitle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the window title. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The name of the window. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2ce0b669cab1762667440695d0ee2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2ce0b669cab1762667440695d0ee2b">&#9670;&nbsp;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ASGE::Renderer::swapBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tells the graphics subsystem to swap buffers. </p>

</div>
</div>
<a id="a83a727c09d0887f527cb2f669139ed3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a727c09d0887f527cb2f669139ed3b">&#9670;&nbsp;</a></span>windowHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ASGE::Renderer::windowHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the window height. </p><dl class="section return"><dt>Returns</dt><dd>The window height. </dd></dl>

</div>
</div>
<a id="a764de80b18463e7a12c23a156bade4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764de80b18463e7a12c23a156bade4ca">&#9670;&nbsp;</a></span>windowWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ASGE::Renderer::windowWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the window width. </p><dl class="section return"><dt>Returns</dt><dd>The window width. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a90d74e4ea8451e7a6251fcab699c8c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d74e4ea8451e7a6251fcab699c8c1d">&#9670;&nbsp;</a></span>active_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_g_e_1_1_render_target.html">ASGE::RenderTarget</a>* ASGE::Renderer::active_buffer { nullptr }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The attached FBO. Used when rendering offscreen to textures. </p>

<p class="definition">Definition at line <a class="el" href="_renderer_8hpp_source.html#l00716">716</a> of file <a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="navelem"><a class="el" href="namespace_a_s_g_e.html">ASGE</a></li><li class="navelem"><a class="el" href="class_a_s_g_e_1_1_renderer.html">Renderer</a></li>
        <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
    </ul>
</div>
</body>
</html>
