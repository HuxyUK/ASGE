<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASGE: ASGE::Sprite Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ASGE
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Simple Game Framework in GL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_a_s_g_e_1_1_sprite.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_a_s_g_e_1_1_sprite-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ASGE::Sprite Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa08b8df5a3a45b638ba454007affe8af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">FlipFlags</a> { <br />
&#160;&#160;<a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8afa1ae2f6f47e142afdae15251e9f5cac5b">NORMAL</a> = 0x00
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8afa893cabee67325f1713cf23d076fa1d0f">FLIP_X</a> = 0x01
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8afabf1a967bfca6676cd50bf1302f0b3b37">FLIP_Y</a> = 0x02
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8afa7ba1a0f59d1914da8da02962397a9a27">FLIP_XY</a> = 0x04
, <br />
&#160;&#160;<a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8afa1ab817f0203719815fea0d19b13b83d7">FLIP_BOTH</a> = FLIP_X | FLIP_Y
<br />
 }</td></tr>
<tr class="separator:aa08b8df5a3a45b638ba454007affe8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bfc78dc178ecd1a045b06176eb764c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764c">SourceRectIndex</a> { <a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764ca41d7921da4ebcaea5f1eb8384e2a38d4">SRC_START_X</a> = 0
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764cabb46b3617083b242d2f4608422ce48f3">SRC_START_Y</a> = 1
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764ca3f53e8bbbc815a16e248c3ab7baf721d">SRC_LENGTH_X</a> = 2
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764ca07c0802dc6eea05e9d9e9072cf29c1b7">SRC_LENGTH_Y</a> = 3
 }</td></tr>
<tr class="separator:a95bfc78dc178ecd1a045b06176eb764c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b143be6a7578a7e2566332bc824de4c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> : int8_t { <br />
&#160;&#160;<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4ca5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a> = 0x00
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4ca2f923e7430e24059a91dc5b99017dba0">KEEP_DIMS</a> = 0x01
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4caa16bc2b7734b86c0b77c908ce473eb51">KEEP_UVS</a> = 0x02
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4ca15d6308d512e8efc414434c5471ddb96">KEEP_TINT</a> = 0x04
, <br />
&#160;&#160;<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4ca7ba70842bb9d07aade110b5409b6a89d">KEEP_ROTATION</a> = 0x08
, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4ca17713cdf4c5ea6612e534aa43ec36004">GENERATE_MIPS</a> = 0x10
<br />
 }</td></tr>
<tr class="separator:a2b143be6a7578a7e2566332bc824de4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8654d09c32c0f96113407e7a4dddb796"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a8654d09c32c0f96113407e7a4dddb796">~Sprite</a> ()=default</td></tr>
<tr class="separator:a8654d09c32c0f96113407e7a4dddb796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b8e3d5b03a674992da67876bf73e23"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ab5b8e3d5b03a674992da67876bf73e23">loadTexture</a> (const std::string &amp;, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> mode)=0</td></tr>
<tr class="separator:ab5b8e3d5b03a674992da67876bf73e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a46a7211752f6baf7742e27f481f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a516a46a7211752f6baf7742e27f481f2">loadTexture</a> (const std::string &amp;)</td></tr>
<tr class="separator:a516a46a7211752f6baf7742e27f481f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4bab3efb18b2ff7b78ef4a55f84693"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a9c4bab3efb18b2ff7b78ef4a55f84693">getTexture</a> () const =0</td></tr>
<tr class="separator:a9c4bab3efb18b2ff7b78ef4a55f84693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dec09cc1a4da913a32a20454ac10a5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#af3dec09cc1a4da913a32a20454ac10a5">xPos</a> () const noexcept</td></tr>
<tr class="separator:af3dec09cc1a4da913a32a20454ac10a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c547e9585a4292528d73e478d6b39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a68c547e9585a4292528d73e478d6b39d">xPos</a> (float x) noexcept</td></tr>
<tr class="separator:a68c547e9585a4292528d73e478d6b39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802c704eec77978a12fa3e664f72c588"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a802c704eec77978a12fa3e664f72c588">yPos</a> () const noexcept</td></tr>
<tr class="separator:a802c704eec77978a12fa3e664f72c588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db36190e101b3693ee2feb77e7b08c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a9db36190e101b3693ee2feb77e7b08c0">yPos</a> (float y) noexcept</td></tr>
<tr class="separator:a9db36190e101b3693ee2feb77e7b08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9771e50714c11d301f90d63a497095e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ac9771e50714c11d301f90d63a497095e">width</a> () const noexcept</td></tr>
<tr class="separator:ac9771e50714c11d301f90d63a497095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db027cd03dc1eddcb7c8ca9ceb9baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa7db027cd03dc1eddcb7c8ca9ceb9baf">width</a> (float width) noexcept</td></tr>
<tr class="separator:aa7db027cd03dc1eddcb7c8ca9ceb9baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619cba6dc8edc60bc1bcb8fdbddbf942"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a619cba6dc8edc60bc1bcb8fdbddbf942">height</a> () const noexcept</td></tr>
<tr class="separator:a619cba6dc8edc60bc1bcb8fdbddbf942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f237378842777b5740ed7a68e3e81c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#af2f237378842777b5740ed7a68e3e81c">height</a> (float height) noexcept</td></tr>
<tr class="separator:af2f237378842777b5740ed7a68e3e81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4feb31bc624909ea3c4a8d976199037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ab4feb31bc624909ea3c4a8d976199037">dimensions</a> (float &amp;<a class="el" href="class_a_s_g_e_1_1_sprite.html#ac9771e50714c11d301f90d63a497095e">width</a>, float &amp;<a class="el" href="class_a_s_g_e_1_1_sprite.html#a619cba6dc8edc60bc1bcb8fdbddbf942">height</a>) const noexcept</td></tr>
<tr class="separator:ab4feb31bc624909ea3c4a8d976199037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769afb63846b2d917202aa7f9f19b89d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a769afb63846b2d917202aa7f9f19b89d">dimensions</a> () const noexcept</td></tr>
<tr class="separator:a769afb63846b2d917202aa7f9f19b89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32450bd0452d4213b0e50f644a4d1feb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a32450bd0452d4213b0e50f644a4d1feb">rotationInRadians</a> () const noexcept</td></tr>
<tr class="separator:a32450bd0452d4213b0e50f644a4d1feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec28f87e0bd20a870cb255fdfb1c68ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aec28f87e0bd20a870cb255fdfb1c68ea">rotationInRadians</a> (float rotation_radians)</td></tr>
<tr class="separator:aec28f87e0bd20a870cb255fdfb1c68ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb888f0eefed1839441f23a9654c031"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a3fb888f0eefed1839441f23a9654c031">scale</a> () const noexcept</td></tr>
<tr class="separator:a3fb888f0eefed1839441f23a9654c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad086f868557a515b434729c9eedf4b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ad086f868557a515b434729c9eedf4b42">scale</a> (float scale_value) noexcept</td></tr>
<tr class="separator:ad086f868557a515b434729c9eedf4b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665595fd4bd6ffcb66e6093704b33ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a665595fd4bd6ffcb66e6093704b33ff2">colour</a> () const noexcept</td></tr>
<tr class="separator:a665595fd4bd6ffcb66e6093704b33ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f757c2400f66e32421355c44e1b228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a48f757c2400f66e32421355c44e1b228">colour</a> (<a class="el" href="struct_a_s_g_e_1_1_colour.html">ASGE::Colour</a> sprite_colour) noexcept</td></tr>
<tr class="separator:a48f757c2400f66e32421355c44e1b228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f5682d1d18ed27049a9807ce13cff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a4e1f5682d1d18ed27049a9807ce13cff">isFlippedOnX</a> () const noexcept</td></tr>
<tr class="separator:a4e1f5682d1d18ed27049a9807ce13cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f639d1ca9176dbf7585bbdc90b9dc7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a6f639d1ca9176dbf7585bbdc90b9dc7a">isFlippedOnY</a> () const noexcept</td></tr>
<tr class="separator:a6f639d1ca9176dbf7585bbdc90b9dc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f99843afe02af82d3177435264572"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#af61f99843afe02af82d3177435264572">isFlippedOnXY</a> () const noexcept</td></tr>
<tr class="separator:af61f99843afe02af82d3177435264572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa721f67dc83511112309625f00be466b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa721f67dc83511112309625f00be466b">setFlipFlags</a> (<a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">FlipFlags</a> flags) noexcept</td></tr>
<tr class="separator:aa721f67dc83511112309625f00be466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bef9746afeca2acb34edd35263bf12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">FlipFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a04bef9746afeca2acb34edd35263bf12">flipFlags</a> () const noexcept</td></tr>
<tr class="separator:a04bef9746afeca2acb34edd35263bf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dbb35370d6256e0ad98c7ca1868278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ab2dbb35370d6256e0ad98c7ca1868278">opacity</a> (float alpha) noexcept</td></tr>
<tr class="separator:ab2dbb35370d6256e0ad98c7ca1868278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276464239a84028f612e54602d78dcdc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a276464239a84028f612e54602d78dcdc">opacity</a> () const noexcept</td></tr>
<tr class="separator:a276464239a84028f612e54602d78dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5b516aee32da9ea275ac12cbf2040d"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aef5b516aee32da9ea275ac12cbf2040d">srcRect</a> () noexcept</td></tr>
<tr class="separator:aef5b516aee32da9ea275ac12cbf2040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbc6d01b044ba29210dec38f85edde7"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a0fbc6d01b044ba29210dec38f85edde7">srcRect</a> () const noexcept</td></tr>
<tr class="separator:a0fbc6d01b044ba29210dec38f85edde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75d4c461f339b5f9c4cbd9e5bb84b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_sprite_bounds.html">SpriteBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ac75d4c461f339b5f9c4cbd9e5bb84b09">getLocalBounds</a> () const noexcept</td></tr>
<tr class="separator:ac75d4c461f339b5f9c4cbd9e5bb84b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334437cee22f1a09e54a7e8a92336352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_sprite_bounds.html">SpriteBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a334437cee22f1a09e54a7e8a92336352">getWorldBounds</a> () const noexcept</td></tr>
<tr class="separator:a334437cee22f1a09e54a7e8a92336352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5775a2cfa85977c1c14c569e5854165f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a5775a2cfa85977c1c14c569e5854165f">attach</a> (<a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *texture2D, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> mode) noexcept=0</td></tr>
<tr class="separator:a5775a2cfa85977c1c14c569e5854165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf680df24dd0a1aaf1455a09a4c37f5"><td class="memItemLeft" align="right" valign="top"><a id="a6bf680df24dd0a1aaf1455a09a4c37f5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>attach</b> (<a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *texture2D) noexcept</td></tr>
<tr class="separator:a6bf680df24dd0a1aaf1455a09a4c37f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293effeef4ab820c78b75d43cbb04e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a293effeef4ab820c78b75d43cbb04e68">midpoint</a> () const</td></tr>
<tr class="separator:a293effeef4ab820c78b75d43cbb04e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fad8c7b6574b17b2013c8696206565"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ab7fad8c7b6574b17b2013c8696206565">getGlobalZOrder</a> () const noexcept</td></tr>
<tr class="separator:ab7fad8c7b6574b17b2013c8696206565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2174c5acb357e66380601d8ee54536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a7d2174c5acb357e66380601d8ee54536">setGlobalZOrder</a> (int16_t new_z_order) noexcept</td></tr>
<tr class="separator:a7d2174c5acb357e66380601d8ee54536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4dc5c6c02b3f0dab1e41bdae0903a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a9d4dc5c6c02b3f0dab1e41bdae0903a9">getPixelShader</a> () const noexcept</td></tr>
<tr class="separator:a9d4dc5c6c02b3f0dab1e41bdae0903a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d05ffbc035be0db4f292ef0d500409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a18d05ffbc035be0db4f292ef0d500409">getPixelShader</a> () noexcept</td></tr>
<tr class="separator:a18d05ffbc035be0db4f292ef0d500409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502cb4121b9125587b506784fadce0b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a502cb4121b9125587b506784fadce0b7">setPixelShader</a> (<a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *shader) noexcept</td></tr>
<tr class="separator:a502cb4121b9125587b506784fadce0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2892fdc1f454835dfaa54c7af7a565bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a2892fdc1f454835dfaa54c7af7a565bb">hasPixelShader</a> () const noexcept</td></tr>
<tr class="separator:a2892fdc1f454835dfaa54c7af7a565bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d28f9c4c1d9013906bae3684110f014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a1d28f9c4c1d9013906bae3684110f014">setMagFilter</a> (<a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a5bcdb98d09f05c5e0df6f8b596773ed5">Texture2D::MagFilter</a> requested_filter) const noexcept</td></tr>
<tr class="separator:a1d28f9c4c1d9013906bae3684110f014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad9037bbe498913a36711debe441ec691"><td class="memItemLeft" align="right" valign="top">std::array&lt; float, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_g_e_1_1_sprite.html#ad9037bbe498913a36711debe441ec691">dimensions</a> ()</td></tr>
<tr class="separator:ad9037bbe498913a36711debe441ec691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab358c111dbd949369bb3634197edbb6f"><td class="memItemLeft" align="right" valign="top"><a id="ab358c111dbd949369bb3634197edbb6f"></a>
<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> lhs, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> rhs)</td></tr>
<tr class="separator:ab358c111dbd949369bb3634197edbb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7d2d52b06cc7eef048db6a8e499077"><td class="memItemLeft" align="right" valign="top"><a id="a6b7d2d52b06cc7eef048db6a8e499077"></a>
<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (<a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> lhs, <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a> rhs)</td></tr>
<tr class="separator:a6b7d2d52b06cc7eef048db6a8e499077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a> supported sprite. </p>
<p>Used to render and load textures. Includes the ability to resize, scale, flip, recolour etc. 2D games are made up of these. This is the interface that defines the platform specific implementation's API. The management and loading of GPU data is handled within the inherited specialisations. </p>

<p class="definition">Definition at line <a class="el" href="_sprite_8hpp_source.html#l00045">45</a> of file <a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2b143be6a7578a7e2566332bc824de4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b143be6a7578a7e2566332bc824de4c">&#9670;&nbsp;</a></span>AttachMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">ASGE::Sprite::AttachMode</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags to control attachments of textures. When attaching a texture to the sprite, by default the sprite's settings will be reset to match the newly attached texture. These flags allow the user to prevent certain resets from occurs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4ca5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"><p>By default, clobber the existing sprite's settings. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4ca2f923e7430e24059a91dc5b99017dba0"></a>KEEP_DIMS&#160;</td><td class="fielddoc"><p>Retain the sprite's dimensions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4caa16bc2b7734b86c0b77c908ce473eb51"></a>KEEP_UVS&#160;</td><td class="fielddoc"><p>Retain the sprite's UV settings. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4ca15d6308d512e8efc414434c5471ddb96"></a>KEEP_TINT&#160;</td><td class="fielddoc"><p>Retain the sprite's tint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4ca7ba70842bb9d07aade110b5409b6a89d"></a>KEEP_ROTATION&#160;</td><td class="fielddoc"><p>Retain the sprite's rotation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b143be6a7578a7e2566332bc824de4ca17713cdf4c5ea6612e534aa43ec36004"></a>GENERATE_MIPS&#160;</td><td class="fielddoc"><p>Generate a new set of MipMaps for the texture. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_sprite_8hpp_source.html#l00085">85</a> of file <a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a>.</p>

</div>
</div>
<a id="aa08b8df5a3a45b638ba454007affe8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08b8df5a3a45b638ba454007affe8af">&#9670;&nbsp;</a></span>FlipFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">ASGE::Sprite::FlipFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to control the flipping of the sprite. </p>
<p>Used to flip the texture's UV coordinates. The flip is performed on the CPU when calculating the UVs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa08b8df5a3a45b638ba454007affe8afa1ae2f6f47e142afdae15251e9f5cac5b"></a>NORMAL&#160;</td><td class="fielddoc"><p>texture is not flipped. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa08b8df5a3a45b638ba454007affe8afa893cabee67325f1713cf23d076fa1d0f"></a>FLIP_X&#160;</td><td class="fielddoc"><p>texture is flipped on the x axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa08b8df5a3a45b638ba454007affe8afabf1a967bfca6676cd50bf1302f0b3b37"></a>FLIP_Y&#160;</td><td class="fielddoc"><p>texture is flipped on the y axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa08b8df5a3a45b638ba454007affe8afa7ba1a0f59d1914da8da02962397a9a27"></a>FLIP_XY&#160;</td><td class="fielddoc"><p>texture is flipped diagonally. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa08b8df5a3a45b638ba454007affe8afa1ab817f0203719815fea0d19b13b83d7"></a>FLIP_BOTH&#160;</td><td class="fielddoc"><p>texture is flipped on both axis. <br  />
 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_sprite_8hpp_source.html#l00054">54</a> of file <a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a>.</p>

</div>
</div>
<a id="a95bfc78dc178ecd1a045b06176eb764c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bfc78dc178ecd1a045b06176eb764c">&#9670;&nbsp;</a></span>SourceRectIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_a_s_g_e_1_1_sprite.html#a95bfc78dc178ecd1a045b06176eb764c">ASGE::Sprite::SourceRectIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple enum to help with src rectangles These enums provide the index numbers that are used for manipulating the UV coordinates when mapping textures to sprites. They form a rectangle that contents delimit the range to use when calculating the source UV coordinates. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95bfc78dc178ecd1a045b06176eb764ca41d7921da4ebcaea5f1eb8384e2a38d4"></a>SRC_START_X&#160;</td><td class="fielddoc"><p>The starting position on the texture's X axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95bfc78dc178ecd1a045b06176eb764cabb46b3617083b242d2f4608422ce48f3"></a>SRC_START_Y&#160;</td><td class="fielddoc"><p>The starting position on the texture's Y axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95bfc78dc178ecd1a045b06176eb764ca3f53e8bbbc815a16e248c3ab7baf721d"></a>SRC_LENGTH_X&#160;</td><td class="fielddoc"><p>The length of the source rectangle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95bfc78dc178ecd1a045b06176eb764ca07c0802dc6eea05e9d9e9072cf29c1b7"></a>SRC_LENGTH_Y&#160;</td><td class="fielddoc"><p>The width of the source rectangle. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_sprite_8hpp_source.html#l00071">71</a> of file <a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8654d09c32c0f96113407e7a4dddb796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8654d09c32c0f96113407e7a4dddb796">&#9670;&nbsp;</a></span>~Sprite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ASGE::Sprite::~Sprite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>The destructor does not free the memory used on the GPU. <b>This is handled inside the platform's specific implementation.</b> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5775a2cfa85977c1c14c569e5854165f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5775a2cfa85977c1c14c569e5854165f">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ASGE::Sprite::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_texture2_d.html">ASGE::Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a texture to the sprite. </p>
<p>Sprites are simply textures which have transform and rendering properties applied to them. They are mostly for convenience of rendering. It is possible to swap out the texture attached to the sprite. Doing so will result the UV coordinates and width and height of the sprite to match the texture, so any changes will need to be reapplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture2D</td><td>The texture to attach. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a665595fd4bd6ffcb66e6093704b33ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665595fd4bd6ffcb66e6093704b33ff2">&#9670;&nbsp;</a></span>colour() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_colour.html">Colour</a> ASGE::Sprite::colour </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the colour of the sprite. </p>
<p>The colour of the sprite can be influenced by providing a tint. The pixel shader will then apply the tint on the resultant pixel when sampling the texture.</p>
<dl class="section return"><dt>Returns</dt><dd>The sprite's colour. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_colour.html" title="RGB Helper.">ASGE::Colour</a> </dd></dl>

</div>
</div>
<a id="a48f757c2400f66e32421355c44e1b228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f757c2400f66e32421355c44e1b228">&#9670;&nbsp;</a></span>colour() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::colour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_colour.html">ASGE::Colour</a>&#160;</td>
          <td class="paramname"><em>sprite_colour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the colour of the sprite. </p>
<p>The colour of the sprite can be influenced by providing a tint. The pixel shader will then apply the tint on the resultant pixel when sampling the texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sprite_colour</td><td>The sprite's colour. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_colour.html" title="RGB Helper.">ASGE::Colour</a> </dd>
<dd>
<a class="el" href="namespace_a_s_g_e_1_1_c_o_l_o_u_r_s.html" title="predefined RGB values">ASGE::COLOURS</a> </dd></dl>

</div>
</div>
<a id="ad9037bbe498913a36711debe441ec691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9037bbe498913a36711debe441ec691">&#9670;&nbsp;</a></span>dimensions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;float, 2&gt;&amp; ASGE::Sprite::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>The array describing the width and height of the sprite. </dd></dl>

</div>
</div>
<a id="a769afb63846b2d917202aa7f9f19b89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769afb63846b2d917202aa7f9f19b89d">&#9670;&nbsp;</a></span>dimensions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;int,int&gt; ASGE::Sprite::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-transformed height and the width of the sprite. </p>
<dl class="section return"><dt>Returns</dt><dd>A tuple representing width and height. </dd></dl>

</div>
</div>
<a id="ab4feb31bc624909ea3c4a8d976199037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4feb31bc624909ea3c4a8d976199037">&#9670;&nbsp;</a></span>dimensions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::dimensions </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-transformed height and the width of the sprite. </p>
<p>Updates the width and the height of two parameters passed in to the function. It does <b>not</b> return a value. The width and height is found in the resultant parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The sprites width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The sprites height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04bef9746afeca2acb34edd35263bf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bef9746afeca2acb34edd35263bf12">&#9670;&nbsp;</a></span>flipFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">FlipFlags</a> ASGE::Sprite::flipFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current flip flags for the sprite. </p>
<p>Flip flags can be used to change the orientation of the texture's render. It does this by altering UV mappings. Use this function to retrieve the current flip flags used for rendering the attached texture.</p>
<dl class="section return"><dt>Returns</dt><dd>flags The flip flags that apply to the texture. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af" title="Flags to control the flipping of the sprite.">ASGE::Sprite::FlipFlags</a> </dd></dl>

</div>
</div>
<a id="ab7fad8c7b6574b17b2013c8696206565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fad8c7b6574b17b2013c8696206565">&#9670;&nbsp;</a></span>getGlobalZOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t ASGE::Sprite::getGlobalZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the rendering order (layer) of the sprite. </p>
<dl class="section return"><dt>Returns</dt><dd>The sprite's current z-order. </dd></dl>

</div>
</div>
<a id="ac75d4c461f339b5f9c4cbd9e5bb84b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75d4c461f339b5f9c4cbd9e5bb84b09">&#9670;&nbsp;</a></span>getLocalBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_sprite_bounds.html">SpriteBounds</a> ASGE::Sprite::getLocalBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the sprite's 4 points in local space. </p>
<p>Simply returns the sprite's original and unmodified dimensions. No transforms will be applied, meaning rotation and scaling are absent and the points can be considered as local or model space. These points can be used as the starting basis of an AABB or for additional collision detection.</p>
<dl class="section return"><dt>Returns</dt><dd>The four vertex bounds of the sprite. </dd></dl>

</div>
</div>
<a id="a9d4dc5c6c02b3f0dab1e41bdae0903a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4dc5c6c02b3f0dab1e41bdae0903a9">&#9670;&nbsp;</a></span>getPixelShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Sprite::getPixelShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves any attached shader. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the shader attached to the sprite. May be null. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html" title="a shader instance. The shader is used in the rendering pipeline.">ASGE::SHADER_LIB::Shader</a> </dd></dl>

</div>
</div>
<a id="a18d05ffbc035be0db4f292ef0d500409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d05ffbc035be0db4f292ef0d500409">&#9670;&nbsp;</a></span>getPixelShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a>* ASGE::Sprite::getPixelShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves any attached shader. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the shader attached to the sprite. May be null. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html" title="a shader instance. The shader is used in the rendering pipeline.">ASGE::SHADER_LIB::Shader</a> </dd></dl>

</div>
</div>
<a id="a9c4bab3efb18b2ff7b78ef4a55f84693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4bab3efb18b2ff7b78ef4a55f84693">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_s_g_e_1_1_texture2_d.html">Texture2D</a>* ASGE::Sprite::getTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function for retrieving the loaded texture. </p>
<p><b>This is handled inside the platform's specific implementation.</b></p>
<dl class="section return"><dt>Returns</dt><dd>The currently attached texture. </dd></dl>

</div>
</div>
<a id="a334437cee22f1a09e54a7e8a92336352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334437cee22f1a09e54a7e8a92336352">&#9670;&nbsp;</a></span>getWorldBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_sprite_bounds.html">SpriteBounds</a> ASGE::Sprite::getWorldBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the sprite's 4 points in world space.</p>
<p>Returns the 4 vertices that delimit the sprite's position in world space. Any transforms (scaling and rotation) have already been applied. This is useful for when you need to know the projected location i.e. calculating a bounding volume.</p>
<dl class="section return"><dt>Returns</dt><dd>The four vertex bounds of the sprite in world space. </dd></dl>

</div>
</div>
<a id="a2892fdc1f454835dfaa54c7af7a565bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2892fdc1f454835dfaa54c7af7a565bb">&#9670;&nbsp;</a></span>hasPixelShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ASGE::Sprite::hasPixelShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if this sprite has a pixel shader attached. </p>
<dl class="section return"><dt>Returns</dt><dd>True if pixel shader is attached. </dd></dl>

</div>
</div>
<a id="a619cba6dc8edc60bc1bcb8fdbddbf942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619cba6dc8edc60bc1bcb8fdbddbf942">&#9670;&nbsp;</a></span>height() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the height of the sprite. </p>
<p>Height is used (along with scale, rotation etc) to determine how tall a sprite will be when it's rendered to the screen. This is the non-transformed height of the sprite.</p>
<dl class="section return"><dt>Returns</dt><dd>The sprites height. </dd></dl>

</div>
</div>
<a id="af2f237378842777b5740ed7a68e3e81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f237378842777b5740ed7a68e3e81c">&#9670;&nbsp;</a></span>height() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::height </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the height of the sprite. </p>
<p>Height is used (along with scale, rotation etc) to determine how tall a sprite will be when it's rendered to the screen. This is the non-transformed height of the sprite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The sprites height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e1f5682d1d18ed27049a9807ce13cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1f5682d1d18ed27049a9807ce13cff">&#9670;&nbsp;</a></span>isFlippedOnX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ASGE::Sprite::isFlippedOnX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if the texture is flipped on the X axis. </p>
<p>It is possible to flip the UV coordinates used on the sprite's texture. This will check to see if the X axis is flipped.</p>
<dl class="section return"><dt>Returns</dt><dd>If the texture is flipped on the X axis. </dd></dl>

</div>
</div>
<a id="af61f99843afe02af82d3177435264572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61f99843afe02af82d3177435264572">&#9670;&nbsp;</a></span>isFlippedOnXY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ASGE::Sprite::isFlippedOnXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if the texture is flipped diagonally. </p>
<dl class="section return"><dt>Returns</dt><dd>If the texture is flipped on the Y axis. </dd></dl>

</div>
</div>
<a id="a6f639d1ca9176dbf7585bbdc90b9dc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f639d1ca9176dbf7585bbdc90b9dc7a">&#9670;&nbsp;</a></span>isFlippedOnY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ASGE::Sprite::isFlippedOnY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if the texture is flipped on the Y axis. </p>
<p>It is possible to flip the UV coordinates used on the sprite's texture. This will check to see if the Y axis is flipped.</p>
<dl class="section return"><dt>Returns</dt><dd>If the texture is flipped on the Y axis. </dd></dl>

</div>
</div>
<a id="a516a46a7211752f6baf7742e27f481f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516a46a7211752f6baf7742e27f481f2">&#9670;&nbsp;</a></span>loadTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASGE::Sprite::loadTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The result of the load operation. </dd></dl>

</div>
</div>
<a id="ab5b8e3d5b03a674992da67876bf73e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b8e3d5b03a674992da67876bf73e23">&#9670;&nbsp;</a></span>loadTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ASGE::Sprite::loadTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_sprite.html#a2b143be6a7578a7e2566332bc824de4c">AttachMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function for loading texture on to the GPU. </p>
<p><b>This is handled inside the platform's specific implementation.</b></p>
<ul>
<li><dl class="section return"><dt>Returns</dt><dd>The result of the load operation. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a293effeef4ab820c78b75d43cbb04e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293effeef4ab820c78b75d43cbb04e68">&#9670;&nbsp;</a></span>midpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_s_g_e_1_1_point2_d.html">ASGE::Point2D</a> ASGE::Sprite::midpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mid-point of the sprite. </p>
<p>Sprites origins are normally 0,0, which maps to the top left. This function returns the mid-point of the sprite based on its with and height and its current position in the world.</p>
<dl class="section note"><dt>Note</dt><dd>This midpoint is scaled using the sprites scale factor. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The midpoint as an <a class="el" href="struct_a_s_g_e_1_1_point2_d.html" title="A point in 2D space.">ASGE::Point2D</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_a_s_g_e_1_1_point2_d.html" title="A point in 2D space.">ASGE::Point2D</a> </dd></dl>

</div>
</div>
<a id="a276464239a84028f612e54602d78dcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276464239a84028f612e54602d78dcdc">&#9670;&nbsp;</a></span>opacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::opacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the opacity of the sprite. </p>
<p>This function let's you obtain the opacity of the sprite. The opacity is controlled by using the alpha channel. 1.0f is opaque and 0.0f is completely transparent.</p>
<dl class="section return"><dt>Returns</dt><dd>The value for the alpha channel. </dd></dl>

</div>
</div>
<a id="ab2dbb35370d6256e0ad98c7ca1868278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2dbb35370d6256e0ad98c7ca1868278">&#9670;&nbsp;</a></span>opacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::opacity </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the opacity of the sprite. </p>
<p>This function let's you control the opacity of the sprite by modifying the alpha channel during the render cycle. 1.0f is opaque and 0.0f is completely transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The new value for the alpha channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32450bd0452d4213b0e50f644a4d1feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32450bd0452d4213b0e50f644a4d1feb">&#9670;&nbsp;</a></span>rotationInRadians() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::rotationInRadians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rotation of the sprite in radians. </p>
<p>The angle of rotation is used to rotate the sprite around it's origin. The origin defaults to the mid-point of the sprite. The angle of rotation is expressed in radians.</p>
<dl class="section return"><dt>Returns</dt><dd>The sprites angle of rotation in radians. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>\((degrees = radians * 180^\theta\ / pi)\) </dd></dl>

</div>
</div>
<a id="aec28f87e0bd20a870cb255fdfb1c68ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec28f87e0bd20a870cb255fdfb1c68ea">&#9670;&nbsp;</a></span>rotationInRadians() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::rotationInRadians </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotation_radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation of the sprite in radians. </p>
<p>The angle of rotation is used to rotate the sprite around it's origin. The origin defaults to the mid-point of the sprite. The angle of rotation is expressed in radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation_radians</td><td>The angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>\((degrees = radians * 180^\theta\ / pi)\) </dd></dl>

</div>
</div>
<a id="a3fb888f0eefed1839441f23a9654c031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb888f0eefed1839441f23a9654c031">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scale of the sprite. </p>
<p>The scale can be adjusted to automatically make the sprite bigger or smaller than it's original size, allowing for on the fly alterations without having to edit the sprite's true size. The scaling operation is performed in both axis.</p>
<dl class="section return"><dt>Returns</dt><dd>The scale factor. </dd></dl>

</div>
</div>
<a id="ad086f868557a515b434729c9eedf4b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad086f868557a515b434729c9eedf4b42">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scale of the sprite. </p>
<p>The scale can be adjusted to automatically make the sprite bigger or smaller than it's original size, allowing for on the fly alterations without having to edit the sprite's true size. The scaling operation is performed in both axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scale_value</td><td>The scaling factor to apply to the sprite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa721f67dc83511112309625f00be466b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa721f67dc83511112309625f00be466b">&#9670;&nbsp;</a></span>setFlipFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::setFlipFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_sprite.html#aa08b8df5a3a45b638ba454007affe8af">FlipFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the flip state of the texture. </p>
<p>It is possible to flip the UV coordinates used on the sprite's texture. This function allows setting of the flip flags. These are then used to control shader's UV mappings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The flip flags to apply to the texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d2174c5acb357e66380601d8ee54536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2174c5acb357e66380601d8ee54536">&#9670;&nbsp;</a></span>setGlobalZOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::setGlobalZOrder </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>new_z_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the rendering order (layer) of the sprite. </p>
<p>When rendering it is often necessary to control the order in which sprites, text or even UI elements are rendered. For example, if parts of the UI were rendered before the background they would end up hidden. Z-ordering is a common approach to controlling this behaviour and is essential when using batch rendering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_z_order</td><td>The z-order to apply to sprite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Typically, an object with a lower z-order will be rendered before one with a higher z-order. In <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a> you can use the z_order property to control the render ordering.</dd></dl>
<p><b>Example</b></p>
<p>In this image you can see an example of when the z-order for a sprite is not set correctly. The blocks below the player should have a lower z-order than the player's sprite to ensure they are rendered first. </p><div class="image">
<img src="https://i.stack.imgur.com/8aGig.png" alt="" width="300"/>
<div class="caption">
GameDev @ StackExchange</div></div>
 
</div>
</div>
<a id="a1d28f9c4c1d9013906bae3684110f014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d28f9c4c1d9013906bae3684110f014">&#9670;&nbsp;</a></span>setMagFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::setMagFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_s_g_e_1_1_game_settings.html#a5bcdb98d09f05c5e0df6f8b596773ed5">Texture2D::MagFilter</a>&#160;</td>
          <td class="paramname"><em>requested_filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the magnification filter on the attached texture. </p>
<p>Use this function to alter the texture sampling behaviour when the attached texture is being read.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_g_e_1_1_texture2_d.html#a4f5fbd285238b66b6e41e588f80f7e0c">ASGE::Texture2D::MagFilter</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requested_filter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a502cb4121b9125587b506784fadce0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502cb4121b9125587b506784fadce0b7">&#9670;&nbsp;</a></span>setPixelShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::setPixelShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_g_e_1_1_s_h_a_d_e_r___l_i_b_1_1_shader.html">SHADER_LIB::Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a shader to the sprite. </p>
<p>When rendering in <a class="el" href="namespace_a_s_g_e.html" title="The simple game framework.">ASGE</a>, it is possible to create custom pixel shaders that can have additional uniforms which can be updated by the developer. You can either flag the renderer to switch shaders, or if you only need a small subset of sprites to use the custom shader, attach them directly. The renderer will take care of switching shaders out when rendering to the GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shader</td><td>The shader to attach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fbc6d01b044ba29210dec38f85edde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbc6d01b044ba29210dec38f85edde7">&#9670;&nbsp;</a></span>srcRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float* ASGE::Sprite::srcRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a read-only source rectangle used for rendering. </p>
<p>It is possible to render a subset of a sprite using a rectangle. The rectangle will use [0] and [1] for the beginning x and y position in the texture and [2] and [3] for the width and height. This is useful when the texture is a sprite sheet.</p>
<dl class="section return"><dt>Returns</dt><dd>The rectangle (as a constant) used for the UV source. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Make sure not to access the pointer out of bounds as this will lead to undefined behaviour. </dd></dl>

</div>
</div>
<a id="aef5b516aee32da9ea275ac12cbf2040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5b516aee32da9ea275ac12cbf2040d">&#9670;&nbsp;</a></span>srcRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float* ASGE::Sprite::srcRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the source rectangle used for rendering. </p>
<p>It is possible to render a subset of a sprite using a rectangle. The rectangle will use [0] and [1] for the beginning x and y position in the texture and [2] and [3] for the width and height. This is useful when the texture is a sprite sheet.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the rectangle array used for the UV source. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Make sure not to access the pointer out of bounds as this will lead to undefined behaviour. </dd></dl>

</div>
</div>
<a id="ac9771e50714c11d301f90d63a497095e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9771e50714c11d301f90d63a497095e">&#9670;&nbsp;</a></span>width() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the width of the sprite. </p>
<p>Width is used (along with scale, rotation etc) to determine how wide/long a sprite will be when it's rendered to the screen. This is the non-transformed width of the sprite.</p>
<dl class="section return"><dt>Returns</dt><dd>The sprites width. </dd></dl>

</div>
</div>
<a id="aa7db027cd03dc1eddcb7c8ca9ceb9baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db027cd03dc1eddcb7c8ca9ceb9baf">&#9670;&nbsp;</a></span>width() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::width </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the width of the sprite. </p>
<p>Width is used (along with scale, rotation etc) to determine how wide/long a sprite will be when it's rendered to the screen. This is the non-transformed width of the sprite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The sprites width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3dec09cc1a4da913a32a20454ac10a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dec09cc1a4da913a32a20454ac10a5">&#9670;&nbsp;</a></span>xPos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::xPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sprite's position on the X axis. </p>
<p><a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> positions are described using Cartesian Coordinates. The horizontal position in this engine is labelled <b>X</b> and runs from left to right. If an <a class="el" href="class_a_s_g_e_1_1_camera.html" title="A 2D orthogonal camera class.">ASGE::Camera</a> is not used it is mapped directly to the screen via the viewport.</p>
<dl class="section return"><dt>Returns</dt><dd>The position current position the x axis. </dd></dl>

</div>
</div>
<a id="a68c547e9585a4292528d73e478d6b39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c547e9585a4292528d73e478d6b39d">&#9670;&nbsp;</a></span>xPos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::xPos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the sprite's position on the X axis. </p>
<p><a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> positions are described using Cartesian Coordinates. The horizontal position in this engine is labelled <b>X</b> and runs from left to right. If an <a class="el" href="class_a_s_g_e_1_1_camera.html" title="A 2D orthogonal camera class.">ASGE::Camera</a> is not used it is mapped directly to the screen via the viewport.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The sprites new position on the x axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a802c704eec77978a12fa3e664f72c588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802c704eec77978a12fa3e664f72c588">&#9670;&nbsp;</a></span>yPos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ASGE::Sprite::yPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sprite's position on the Y axis. </p>
<p><a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> positions are described using Cartesian Coordinates. The vertical position in this engine is labelled <b>y</b> and runs from top to bottom. If an <a class="el" href="class_a_s_g_e_1_1_camera.html" title="A 2D orthogonal camera class.">ASGE::Camera</a> is not used it is mapped directly to the screen via the viewport.</p>
<dl class="section return"><dt>Returns</dt><dd>The sprites new position on the y axis </dd></dl>

</div>
</div>
<a id="a9db36190e101b3693ee2feb77e7b08c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db36190e101b3693ee2feb77e7b08c0">&#9670;&nbsp;</a></span>yPos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASGE::Sprite::yPos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sprite's position on the Y axis. </p>
<p><a class="el" href="class_a_s_g_e_1_1_sprite.html" title="An ASGE supported sprite.">Sprite</a> positions are described using Cartesian Coordinates. The vertical position in this engine is labelled <b>y</b> and runs from top to bottom.If an <a class="el" href="class_a_s_g_e_1_1_camera.html" title="A 2D orthogonal camera class.">ASGE::Camera</a> is not used it is mapped directly to the screen via the viewport.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The new position on the y axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_sprite_8hpp_source.html">Sprite.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="navelem"><a class="el" href="namespace_a_s_g_e.html">ASGE</a></li><li class="navelem"><a class="el" href="class_a_s_g_e_1_1_sprite.html">Sprite</a></li>
        <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
    </ul>
</div>
</body>
</html>
